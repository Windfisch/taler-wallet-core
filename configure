#!/bin/sh

# This file is part of TALER
# (C) 2019 GNUnet e.V.
#
# This is very simple POSIX sh script which
# identifies the first matching
# python3 identifier in $PATH and produces
# configure.py from configure.py.in, and then
# calls the new executable configure.py.
#
# It should be portable on Unices. Report bugs on
# the bugtracker if you discover that it isn't
# working as intended.
#
# Authors:
# Author: ng0 <ng0@taler.net>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE
# LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
# THIS SOFTWARE.
#
# SPDX-License-Identifier: 0BSD

# there is a function used in curl to replicate which(1), but
# it uses too many other tools. this one uses command and in
# gnunet so far has no reports about failures.
existence()
{
    command -v "$1" >/dev/null 2>&1
}

# We have to check every possible variant of the
# executable name because there is a PEP which
# defines the executable to be like this.
if existence python3; then
    python="python3"
elif existence python3.1; then
    python="python3.1"
elif existence python3.2; then
    python="python3.2"
elif existence python3.3; then
    python="python3.3"
elif existence python3.4; then
    python="python3.4"
elif existence python3.5; then
    python="python3.5"
elif existence python3.6; then
    python="python3.6"
elif existence python3.7; then
    python="python3.7"
elif existence python3.8; then
    python="python3.8"
else
    echo "*** No known python3 executable found in path ***"
    echo "*** falling back to env(1) python             ***"
    # Unreliable, but if env finds no python, we still can
    # not assume python in a fixed location.
    # TODO: Check this in a clean chroot!
    python="env python"
fi

# we could check the return value here via || echo "blafoo"
# or fail anyway once configure.py is invoked because we
# don't have python if we reach the point to fail.
PYTHON=$($python -c 'import sys; print(sys.executable)')
#echo $PYTHON

if ! existence node; then
    echo 'Error: node executable not found.'
    echo 'If you are using Linux, Ubuntu or Debian, try installing the'
    echo 'node-legacy package or symlink node to nodejs.'
else
    node_version=$(node --version)
    #echo "Using node ${node_version}"
    if ! node -p 'process.exit(!(/v([0-9]+)/.exec(process.version)[1] >= 4))'; then
        echo 'Your node version is too old, use Node 4.x or newer'
        exit 1
    fi
fi

if existence yarn; then
    if yarn help 2>&1 | grep "No such file or directory"; then
        echo "ERROR: wrong yarn binary installed, please remove the"
        echo "ERROR: conflicting binary before continuing."
        if existence cmdtest; then
            echo "WARNING: cmdtest is installed, this can lead"
            echo "WARNING: to know issues with yarn."
        fi
        exit 1
    fi
    myyarn="yarn"
elif existence yarnpkg; then
    myyarn="yarnpkg"
else
    echo 'ERROR: yarn missing. See https://yarnpkg.com/en/docs/install'
    exit 1
fi

# for the weird systems and sandboxes, only as a anotice.
# make will fail anyway.
if ! existence find; then
    echo "INFO: find(1) is missing"
fi
if ! existence xargs; then
    echo "INFO: xargs(1) is missing"
fi
if ! existence msgmerge; then
    echo "INFO: msgmerge(1) is missing"
fi

# Call configure.py, assuming all went well.
# $1 is read by configure.py as the prefix.
# If $1 is empty, the python script checks the
# environment for PREFIX. We might need more
# variables and switches, such as DESTDIR.
$PYTHON ./configure.py --yarn=$myyarn $@
